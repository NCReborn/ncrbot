const { SlashCommandBuilder, PermissionsBitField } = require('discord.js');
const {
  fetchRevision, getCollectionSlug, getCollectionName,
  computeDiff, findExclusiveChanges, processModFiles
} = require('../utils/nexusApi');
const { sendCombinedChangelogMessages, sendSingleChangelogMessages } = require('../services/changelogService');
const { sendE33ChangelogMessages } = require('../services/changelogServiceE33');
const logger = require('../utils/logger');
const { checkAndSetRateLimit } = require('../utils/rateLimiter');
const { errorEmbed } = require('../utils/discordUtils');
const CONSTANTS = require('../config/constants');

module.exports = {
  data: new SlashCommandBuilder()
    .setName('diff')
    .setDescription('Show mod differences between collection revisions (Admin only)')
    .addStringOption(option =>
      option.setName('collection1').setDescription('First collection name (e.g. NCR, ADR)').setRequired(true))
    .addIntegerOption(option =>
      option.setName('oldrev1').setDescription('Old revision number for collection 1').setRequired(true))
    .addIntegerOption(option =>
      option.setName('newrev1').setDescription('New revision number for collection 1').setRequired(true))
    .addStringOption(option =>
      option.setName('collection2').setDescription('Second collection name (optional)').setRequired(false))
    .addIntegerOption(option =>
      option.setName('oldrev2').setDescription('Old revision number for collection 2 (optional)').setRequired(false))
    .addIntegerOption(option =>
      option.setName('newrev2').setDescription('New revision number for collection 2 (optional)').setRequired(false)),
  async execute(interaction) {
    await interaction.deferReply({ ephemeral: true });

    const username = `${interaction.user.tag} (${interaction.user.id})`;

    if (!interaction.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
      logger.warn(`[DIFF] Permission denied for ${username} in guild ${interaction.guildId}`);
      await interaction.editReply({ embeds: [errorEmbed('Permission Denied', 'This command is only available to administrators.')] });
      return;
    }

    // Global rate limit
    const globalKey = 'diff:global';
    const globalLeft = checkAndSetRateLimit(globalKey, CONSTANTS.COOLDOWNS.GLOBAL_COMMAND);
    if (globalLeft > 0) {
      logger.info(`[DIFF] Global cooldown hit by ${username} (${globalLeft}s left)`);
      await interaction.editReply({ embeds: [errorEmbed('Global Cooldown', `⏳ Please wait ${globalLeft} more second(s) before anyone can use this command again.`)] });
      return;
    }

    // Per-user rate limit with consistent key: diff:user:<userId>
    const userKey = `diff:user:${interaction.user.id}`;
    const userLeft = checkAndSetRateLimit(userKey, CONSTANTS.COOLDOWNS.USER_COMMAND);
    if (userLeft > 0) {
      logger.info(`[DIFF] User cooldown hit by ${username} (${userLeft}s left)`);
      await interaction.editReply({ embeds: [errorEmbed('User Cooldown', `⏳ You must wait ${userLeft} more minute(s) before you can use this command again.`)] });
      return;
    }

    const c1 = interaction.options.getString('collection1');
    const old1 = interaction.options.getInteger('oldrev1');
    const new1 = interaction.options.getInteger('newrev1');
    const c2 = interaction.options.getString('collection2');
    const old2 = interaction.options.getInteger('oldrev2');
    const new2 = interaction.options.getInteger('newrev2');

    try {
      if (!c2 || old2 === null || new2 === null) {
        const slug = getCollectionSlug(c1);
        const collectionName = getCollectionName(slug);

        const [oldData, newData] = await Promise.all([
          fetchRevision(slug, old1, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION),
          fetchRevision(slug, new1, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION)
        ]);

        const oldMods = processModFiles(oldData.modFiles);
        const newMods = processModFiles(newData.modFiles);
        const diffs = computeDiff(oldMods, newMods);

        const isFirstRevision = !old1 || old1 === 0 || String(old1) === '1';

        // Use the E33 handler for Expedition 33, otherwise regular
        if (slug === 'jzmqt4') {
          if (isFirstRevision) {
            await sendE33ChangelogMessages(
              interaction.channel, diffs, slug, old1, new1, collectionName, "1.5.1", newMods
            );
          } else {
            await sendE33ChangelogMessages(
              interaction.channel, diffs, slug, old1, new1, collectionName
            );
          }
        } else {
          await sendSingleChangelogMessages(interaction.channel, diffs, slug, old1, new1, collectionName);
        }
        await interaction.editReply({ content: `Changelog for ${collectionName} ${old1} → ${new1}:` });
        logger.info(`[DIFF] Changelog for ${collectionName} ${old1}→${new1} generated by ${username} in guild ${interaction.guildId}`);
      } else {
        const slug1 = getCollectionSlug(c1);
        const slug2 = getCollectionSlug(c2);

        const [oldData1, newData1, oldData2, newData2] = await Promise.all([
          fetchRevision(slug1, old1, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION),
          fetchRevision(slug1, new1, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION),
          fetchRevision(slug2, old2, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION),
          fetchRevision(slug2, new2, process.env.NEXUS_API_KEY, process.env.APP_NAME, process.env.APP_VERSION)
        ]);

        const oldMods1 = processModFiles(oldData1.modFiles);
        const newMods1 = processModFiles(newData1.modFiles);
        const oldMods2 = processModFiles(oldData2.modFiles);
        const newMods2 = processModFiles(newData2.modFiles);

        const diffs1 = computeDiff(oldMods1, newMods1);
        const diffs2 = computeDiff(oldMods2, newMods2);
        const exclusiveChanges = findExclusiveChanges(diffs1, diffs2);

        await sendCombinedChangelogMessages(interaction.channel, diffs1, diffs2, exclusiveChanges, slug1, old1, new1, slug2, old2, new2);
        await interaction.editReply({ content: `Combined changelog for ${c1} and ${c2}:` });
        logger.info(`[DIFF] Combined changelog for ${c1} and ${c2} generated by ${username} in guild ${interaction.guildId}`);
      }
    } catch (err) {
      logger.error(`[DIFF] Error for ${username} in guild ${interaction.guildId}: ${err.stack || err}`);
      await interaction.editReply({ embeds: [errorEmbed('Error Generating Changelog', err.message)] });
    }
  }
};
